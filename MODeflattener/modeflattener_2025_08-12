from future.utils import viewitems, viewvalues
from miasm.analysis.binary import Container
from miasm.analysis.machine import Machine
from miasm.core.locationdb import LocationDB
from miasm.analysis.simplifier import *
from miasm.expression.expression import *
from miasm.core.asmblock import *
from miasm.arch.x86.arch import mn_x86
from miasm.core.utils import encode_hex
from mod_utils import _backtrack_mem_to_imm
from mod_utils import _mem_key_from_exprmem
from miasm.expression.expression import ExprLoc
from miasm.expression.expression import ExprOp, ExprMem, ExprId, ExprInt, ExprLoc

from mod_utils import (
    _is_reg, _is_imm, _as_int,
    _is_switchvar_mem, _backtrack_reg_to_imm,
    _find_tail_jmp_to_dispatcher, make_rel32_jmp_bytes,
    _backtrack_mem_to_imm,
    _decide_cmov,
    _capture_stack_consts_for_next,   # â† ì¶”ê°€
    _capture_regs_for_next, 
    get_cff_info,
)

from argparse import ArgumentParser
import time
import logging
import pprint

class PatchNop:
    def __init__(self, offset, size):
        self.offset = offset
        self.data = b'\x90' * size  # NOP opcode (0x90) * size
        
        
class PatchBytes:
    def __init__(self, offset, data: bytes):
        self.offset = offset
        self.data = data


def _mem_key_from_exprmem(m):
    # ExprMem í˜•íƒœì—ì„œ (BASE, OFF) í‚¤ ì¶”ì¶œ: ('RBP', -0x10) ê°™ì€ í˜•íƒœ
    if isinstance(m, ExprMem) and isinstance(m.ptr, ExprOp) and m.ptr.op == '+':
        base, off = m.ptr.args
        if _is_reg(base) and isinstance(off, ExprInt):
            base_name = base.name.upper()
            offv = off.arg if off.arg < (1 << 63) else off.arg - (1 << 64)
            return (base_name, offv)
    return None

  
def _succ_offsets(asmcfg, bb):
    """ ë²„ì „ ë…ë¦½ì ìœ¼ë¡œ í›„ì† ë¸”ë¡ offset ë¦¬ìŠ¤íŠ¸ ì–»ê¸° """
    offs = []
    for succ in getattr(bb, "bto", []):
        loc_key = None
        from miasm.expression.expression import ExprLoc
        if isinstance(succ, ExprLoc):
            loc_key = succ.loc_key
        elif hasattr(succ, "loc_key"):
            loc_key = getattr(succ, "loc_key")
        elif hasattr(succ, "arg") and isinstance(getattr(succ, "arg"), ExprLoc):
            loc_key = succ.arg.loc_key
        else:
            continue
        try:
            off = asmcfg.loc_db.get_location_offset(loc_key)
            offs.append(off)
        except Exception:
            continue
    return offs

def _last_jmp_target_addr(asmcfg, block):
    """ ë¸”ë¡ ë§ˆì§€ë§‰ì´ JMPë¼ë©´ ê·¸ ëª©ì ì§€(ì •ìˆ˜ ì£¼ì†Œ) ë°˜í™˜, ì•„ë‹ˆë©´ None """
    if not block.lines:
        return None
    last = block.lines[-1]
    if last.name.lower() != 'jmp' or not last.args:
        return None
    dst = last.args[0]
    if isinstance(dst, ExprInt):
        return dst.arg
    if isinstance(dst, ExprLoc):
        return asmcfg.loc_db.get_location_offset(dst.loc_key)
    return None


def _is_compare_node(block):
    """ (sub|cmp) eax, IMM ; je/jz ... ê°€ ê°™ì€ ë¸”ë¡ ì•ˆì— ì¡´ì¬í•˜ë©´ ë¹„êµ ë…¸ë“œë¡œ ë³¸ë‹¤ """
    saw_imm_cmp = False
    for ins in block.lines:
        nm = ins.name.lower()
        if nm in ('sub', 'cmp') and len(ins.args) == 2:
            if _is_reg(ins.args[0], 'EAX') and _is_imm(ins.args[1]):
                saw_imm_cmp = True
        if nm in ('je', 'jz') and saw_imm_cmp:
            return True
    return False


def build_dispatcher_map(asmcfg, dispatcher_addr):
    """
    1) dispatcher_addrì—ì„œ ì‹œì‘í•´ BFSë¡œ ë¹„êµ ë…¸ë“œë“¤ì„ ë”°ë¼ê°€ë©° state->target ìˆ˜ì§‘
    2) ë³´ê°•: í•¨ìˆ˜ ë‚´ ëª¨ë“  ë¸”ë¡ì„ ìˆœíšŒí•˜ë©° (sub|cmp eax,IMM ; je T) íŒ¨í„´ì´ë©´
       T ë¸”ë¡ì˜ ë§ˆì§€ë§‰ JMPê°€ dispatcherë¡œ ë³µê·€í•˜ëŠ”ì§€ í™•ì¸í•´ì„œ mapì— ì¶”ê°€
    """
    m = {}
    visited = set()
    work = [dispatcher_addr]

    # --- (1) BFS ì²´ì¸ ì¶”ì  ---
    while work:
        cur = work.pop()
        if cur in visited:
            continue
        visited.add(cur)

        bb = asmcfg.getby_offset(cur)
        ins = bb.lines
        imm_val = None

        # ê°™ì€ ë¸”ë¡ ì•ˆì—ì„œ (sub|cmp eax,IMM) â†’ (je/jz T) íŒ¨í„´ ì¶”ì¶œ
        for op in ins:
            nm = op.name.lower()
            if nm in ('sub', 'cmp') and len(op.args) == 2:
                if _is_reg(op.args[0], 'EAX') and _is_imm(op.args[1]):
                    imm_val = _as_int(op.args[1])
            elif nm in ('je', 'jz') and op.args and imm_val is not None:
                dst = op.args[0]
                if isinstance(dst, ExprInt):
                    tgt_addr = dst.arg
                elif isinstance(dst, ExprLoc):
                    tgt_addr = asmcfg.loc_db.get_location_offset(dst.loc_key)
                else:
                    tgt_addr = None
                if tgt_addr is not None:
                    m[imm_val] = tgt_addr

        # í›„ì† í›„ë³´ë“¤ ëª¨ë‘ ë„£ê¸° (fall-through, jmp $+5, ê¸°íƒ€)
        for nxt in _succ_offsets(asmcfg, bb):
            try:
                nxt_bb = asmcfg.getby_offset(nxt)
            except Exception:
                continue
            # ë¹„êµ ë…¸ë“œë©´ ê³„ì† ì¶”ì 
            if _is_compare_node(nxt_bb):
                work.append(nxt)

        # ë§ˆì§€ë§‰ ëª…ë ¹ì´ JMPë©´ ê·¸ ëª©ì ì§€ë„ ë¹„êµë…¸ë“œë¼ë©´ ì¶”ì 
        tail = _last_jmp_target_addr(asmcfg, bb)
        if tail is not None:
            try:
                tail_bb = asmcfg.getby_offset(tail)
                if _is_compare_node(tail_bb):
                    work.append(tail)
            except Exception:
                pass

    # --- (2) ë¸Œë£¨íŠ¸í¬ìŠ¤ ë³´ê°•: í•¨ìˆ˜ ì „ì²´ì—ì„œ 'dispatcher ë³µê·€' íƒ€ê²Ÿë§Œ ì¶”ê°€ ---
    for block in asmcfg.blocks:
        ins = block.lines
        imm_val = None
        tgt_addr = None

        for op in ins:
            nm = op.name.lower()
            if nm in ('sub', 'cmp') and len(op.args) == 2:
                if _is_reg(op.args[0], 'EAX') and _is_imm(op.args[1]):
                    imm_val = _as_int(op.args[1])
            elif nm in ('je', 'jz') and op.args and imm_val is not None:
                dst = op.args[0]
                if isinstance(dst, ExprInt):
                    tgt_addr = dst.arg
                elif isinstance(dst, ExprLoc):
                    tgt_addr = asmcfg.loc_db.get_location_offset(dst.loc_key)
                else:
                    tgt_addr = None

                if tgt_addr is not None:
                    # ì´ íƒ€ê²Ÿ ë¸”ë¡ì´ dispatcherë¡œ ë³µê·€í•˜ë©´ dispatcher chainì˜ í•œ caseë¡œ ì¸ì •
                    try:
                        tgt_bb = asmcfg.getby_offset(tgt_addr)
                    except Exception:
                        continue
                    j = _last_jmp_target_addr(asmcfg, tgt_bb)
                    if j == dispatcher_addr:
                        m[imm_val] = tgt_addr

    # ë””ë²„ê·¸ ì¶œë ¥
    if not m:
        print("[WARN] dispatcher map empty")
    else:
        print("[DEBUG] dispatcher map:")
        for k, v in sorted(m.items()):
            print(f"  state {hex(k)} -> {hex(v)}")
    return m


def _backtrack_reg_to_imm_or_pair(lines, reg):
    tgt = reg.name
    for i in range(len(lines)-1, -1, -1):
        ins = lines[i]
        nm = ins.name.lower()

        # mov reg, IMM
        if nm == 'mov' and len(ins.args)==2:
            dst, src = ins.args
            if _is_reg(dst, tgt) and _is_imm(src):
                return {_as_int(src)}

        # cmov* reg, src_reg  â†’ ë‘˜ ë‹¤ ì§ì „ IMMì´ë©´ {imm1, imm2}
        if nm.startswith('cmov') and len(ins.args)==2:
            dst, src = ins.args
            if _is_reg(dst, tgt) and _is_reg(src):
                imm_dst = _backtrack_reg_to_imm(lines[:i], dst)
                imm_src = _backtrack_reg_to_imm(lines[:i], src)
                s = set()
                if imm_dst is not None: s.add(imm_dst)
                if imm_src is not None: s.add(imm_src)
                if s: return s
    return None


def extract_next_state(block, known_mem=None, known_regs=None):
    if known_mem  is None: known_mem  = {}
    if known_regs is None: known_regs = {}
    lines = block.lines

    for idx in range(len(lines)-1, -1, -1):
        ins = lines[idx]
        if ins.name.lower() == 'mov' and len(ins.args) == 2:
            dst, src = ins.args
            if _is_switchvar_mem(dst):
                # 1) ì§ì ‘ IMM ì €ì¥
                if _is_imm(src):
                    return { _as_int(src) }

                # 2) reg â†’ mem ì €ì¥
                if _is_reg(src):
                    base_set = _backtrack_reg_to_imm_or_pair(lines[:idx+1], src)

                    # 2-1) ì´ë¯¸ ë‹¨ì¼ IMMë¡œ í™•ì •ëœ ê²½ìš° ì¦‰ì‹œ ë°˜í™˜
                    if base_set and len(base_set) == 1:
                        return base_set

                    # 2-2) cmov ë‹¨ì¼í™” ì‹œë„ (base_setì´ Noneì´ê±°ë‚˜ 2ê°œ ì´ìƒì¼ ë•Œ)
                    imm_a = imm_b = None
                    relop = None
                    L_const = R_const = None
                    src_reg_name = None   # â˜… ì¶”ê°€

                    scan_lim = 32
                    for j in range(idx-1, max(-1, idx-scan_lim), -1):
                        pj = lines[j]; nm = pj.name.lower()

                        # cmov* eax, <reg>  â†’ src_reg_name ê¸°ì–µ + relop ê¸°ë¡
                        if nm.startswith('cmov') and len(pj.args) == 2 and _is_reg(pj.args[0], 'EAX') and _is_reg(pj.args[1]):
                            src_reg_name = pj.args[1].name.upper()
                            rel_map = {
                                'cmovle':'le','cmovl':'l','cmovge':'ge','cmovg':'g',
                                'cmovz':'z','cmovnz':'nz',
                                'cmova':'a','cmovae':'ae','cmovb':'b','cmovbe':'be',
                            }
                            relop = rel_map.get(nm, relop)
                            continue

                        # mov eax, IMM / mov <src_reg>, IMM
                        if nm == 'mov' and len(pj.args)==2 and _is_reg(pj.args[0]) and _is_imm(pj.args[1]):
                            r = pj.args[0].name.upper()
                            if r == 'EAX':
                                imm_a = _as_int(pj.args[1])
                            elif src_reg_name and r == src_reg_name:
                                imm_b = _as_int(pj.args[1])

                        # cmp L, R
                        if nm == 'cmp' and len(pj.args) == 2:
                            L, R = pj.args

                            # --- L ---
                            if _is_imm(L):
                                L_const = _as_int(L)
                            elif _is_reg(L):
                                # 1) known_regs ìš°ì„ 
                                _rname = L.name.upper()
                                L_const = known_regs.get(_rname)
                                # 2) ì—†ìœ¼ë©´ ì—­ì¶”ì 
                                if L_const is None:
                                    L_const = _backtrack_reg_to_imm(lines[:j+1], L)
                            elif isinstance(L, ExprMem):
                                key = _mem_key_from_exprmem(L)
                                if known_mem is not None and key in known_mem:
                                    L_const = known_mem[key]
                                else:
                                    mem = _backtrack_mem_to_imm(
                                        lines[:j+1],
                                        base_names=('RBP', 'RSP'),
                                        off_candidates=(-0x4, -0x8, -0xC, -0x10, -0x14, -0x18, -0x1C, -0x20)
                                    )
                                    if mem is not None:
                                        _, _, L_const = mem

                            # --- R ---
                            if _is_imm(R):
                                R_const = _as_int(R)
                            elif _is_reg(R):
                                _rname = R.name.upper()
                                R_const = known_regs.get(_rname)
                                if R_const is None:
                                    R_const = _backtrack_reg_to_imm(lines[:j+1], R)
                            elif isinstance(R, ExprMem):
                                key = _mem_key_from_exprmem(R)
                                if known_mem is not None and key in known_mem:
                                    R_const = known_mem[key]
                                else:
                                    mem = _backtrack_mem_to_imm(
                                        lines[:j+1],
                                        base_names=('RBP', 'RSP'),
                                        off_candidates=(-0x4, -0x8, -0xC, -0x10, -0x14, -0x18, -0x1C, -0x20)
                                    )
                                    if mem is not None:
                                        _, _, R_const = mem

                        

                    # ëª¨ë“  ì¬ë£Œê°€ ëª¨ì˜€ìœ¼ë©´ ê²°ì • ì‹œë„
                    if relop and (imm_a is not None) and (imm_b is not None) and (L_const is not None) and (R_const is not None):
                        decided = _decide_cmov(imm_a, imm_b, relop, L_const, R_const)
                        if decided is not None:
                            return {decided}

                    # 2-3) cmov ë‹¨ì¼í™” ì‹¤íŒ¨: base_setì´ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜(2ê°œ í›„ë³´), ì•„ë‹ˆë©´ ë¶ˆí™•ì •
                    if base_set:
                        return base_set
                    return None


def setup_logger(loglevel):
    FORMAT = '[%(levelname)s] %(message)s'
    logging.basicConfig(format=FORMAT)
    logger = logging.getLogger('modeflattener')

    numeric_level = getattr(logging, loglevel.upper(), None)
    if not isinstance(numeric_level, int):
        raise ValueError('Invalid log level: %s' % loglevel)

    logger.setLevel(numeric_level)

    return logger

# https://synthesis.to/2021/03/15/control_flow_analysis.html
def calc_flattening_score(graph):
    cnt_cmp_or_sub = 0
    cnt_je_or_jmp = 0
    cnt_blocks = 0

    for block in graph.blocks:
        lines = block.lines
        for i, line in enumerate(lines):
            if line.name.startswith("sub") or line.name.startswith("cmp"):
                cnt_cmp_or_sub += 1
            elif line.name.startswith("je") or line.name.startswith("jmp"):
                cnt_je_or_jmp += 1
        cnt_blocks += 1

    if cnt_blocks == 0:
        return 0.0

    score = (cnt_cmp_or_sub + cnt_je_or_jmp) / float(cnt_blocks * 2)
    return score


# callback to stop disassembling when it encounters any jump
def stop_on_jmp(mdis, cur_bloc, offset_to_dis):
    jmp_instr_check = cur_bloc.lines[-1].name in ['JMP','JZ','JNZ']

    if jmp_instr_check:
        cur_bloc.bto.clear()
        offset_to_dis.clear()


                   
def _is_jcc(ins):
    nm = ins.name.lower()
    return nm.startswith('j') and nm != 'jmp'  # jz, jnz, jl, jg, ...

def _branch_target_as_int(expr):
    # ExprLoc(offset=...), ExprInt(arg=...) ë‘˜ ë‹¤ ì •ìˆ˜ ì˜¤í”„ì…‹ìœ¼ë¡œ í†µì¼
    if hasattr(expr, 'offset'):
        try: return int(expr.offset)
        except Exception: return None
    if hasattr(expr, 'arg'):
        try: return int(expr.arg)
        except Exception: return None
    return None

def make_rel32_jcc_bytes(from_off, to_off, cond_name):
    """
    0F 80+cc  imm32  (ì´ 6ë°”ì´íŠ¸)
    disp = to_off - (from_off + 6)
    cond_name: 'jz', 'jnz' ë“± ì†Œë¬¸ì
    """
    cond_name = cond_name.lower()
    cc_map = {
        'jo':0x00,'jno':0x01,'jb':0x02,'jnae':0x02,'jc':0x02,
        'jnb':0x03,'jae':0x03,'jnc':0x03,'jz':0x04,'je':0x04,
        'jnz':0x05,'jne':0x05,'jbe':0x06,'jna':0x06,'ja':0x07,
        'jg':0x0F,'jnle':0x0F,'jge':0x0D,'jnl':0x0D,'jl':0x0C,
        'jnge':0x0C,'jle':0x0E,'jng':0x0E,'js':0x08,'jns':0x09,
        'jp':0x0A,'jpe':0x0A,'jnp':0x0B,'jpo':0x0B,
    }
    if cond_name not in cc_map:
        raise ValueError(f"unsupported jcc: {cond_name}")
    cc = cc_map[cond_name]
    disp = to_off - (from_off + 6)
    imm = disp & 0xFFFFFFFF
    return bytes([0x0F, 0x80 + cc,
                  imm & 0xFF, (imm>>8)&0xFF, (imm>>16)&0xFF, (imm>>24)&0xFF])
    
    
def peephole_fold_jcc_skip_jmp(block, dispatcher_addr=None, forbid_offsets=None):
    """
    íŒ¨í„´: jcc +5 ; jmp $+5 ; jmp TARGET  (ë³´í†µ TARGET=dispatcher)
    - ì•ˆì „í•˜ë©´ 'jcc TARGET(near)' ë¡œ ì ‘ê³ , ë‚˜ë¨¸ì§€ëŠ” NOP
    - ì•„ë‹ˆë©´ ìµœì†Œí•œ jmp $+5 ë¥¼ NOP í•˜ë˜, forbid_offsetsì— ì§€ì •ëœ ì˜¤í”„ì…‹ì€ ê±´ë„ˆëœ€
    ë°˜í™˜: [PatchNop(...), PatchBytes(...), ...]
    """
    if forbid_offsets is None:
        forbid_offsets = set()

    patches = []
    lines = getattr(block, "lines", []) or []

    # ì•„ì£¼ ë³´ìˆ˜ì ì¸ ë§¤ì¹­: [i]=jcc short +5, [i+1]=jmp $+5, [i+2]=jmp rel32 target
    for i in range(len(lines) - 2):
        a, b, c = lines[i], lines[i+1], lines[i+2]
        an, bn, cn = a.name.lower(), b.name.lower(), c.name.lower()

        # a: jz/jnz/jl/jle/... short (+5) ë§Œ í—ˆìš©
        if an.startswith('j') and an != 'jmp':
            # jcc ì¸ì§€ & ì¦‰ì‹œê°’ +5 ì¸ì§€
            if len(a.args) == 1 and _is_imm(a.args[0]) and _as_int(a.args[0]) == 5:
                # b: jmp $+5 (short)
                if bn == 'jmp' and len(b.args) == 1 and _is_imm(b.args[0]) and _as_int(b.args[0]) == 5:
                    # c: jmp <target> (near rel32ë¡œ ë””ìŠ¤ì–´ì…ˆë¸”ë˜ì–´ ìˆì„ ê²ƒ)
                    if cn == 'jmp' and len(c.args) == 1:
                        # target ì ˆëŒ€ì£¼ì†Œ ì–»ê¸° (í‘œí˜„ì‹ íƒ€ì…ì— ë”°ë¼ ë³´ì •)
                        tgt = None
                        try:
                            tgt = _as_int(c.args[0])  # ExprInt/ExprLoc ëª¨ë‘ ì»¤ë²„ë˜ë„ë¡ _as_intê°€ êµ¬í˜„ë¨ì„ ê°€ì •
                        except Exception:
                            pass

                        # ì¼ë‹¨ ìµœì†Œí•œ: forbid_offsets ì•„ë‹Œ ê²½ìš°ì—ë§Œ jmp $+5 NOP
                        if b.offset not in forbid_offsets:
                            patches.append(PatchNop(b.offset, b.l))

                        # ë” ë‚˜ì•„ê°€ ì ‘ì„ ìˆ˜ ìˆìœ¼ë©´ jccë¥¼ near(6ë°”ì´íŠ¸)ë¡œ ì¬ì‘ì„± + c(near jmp) NOP
                        # (ì•ˆì „ì„±ì„ ìœ„í•´ jz/jnz ì •ë„ë§Œ ì²˜ë¦¬; ë‚˜ë¨¸ì§€ëŠ” ê¸°ì¡´ì²˜ëŸ¼ jmp $+5ë§Œ NOP)
                        if tgt is not None and an in ('jz', 'jnz'):
                            try:
                                jcc_bytes = make_rel32_jcc_bytes(a.offset, tgt, an)  # ì•„ë˜ í—¬í¼ ì¶”ê°€ í•„ìš”
                                # a ìœ„ì¹˜ì— 6ë°”ì´íŠ¸ ë®ì–´ì“°ê¸° íŒ¨ì¹˜
                                patches.append(PatchBytes(a.offset, jcc_bytes))
                                # c(near jmp) ì œê±°
                                if c.offset not in forbid_offsets:
                                    patches.append(PatchNop(c.offset, c.l))
                            except Exception:
                                # ì‹¤íŒ¨í•˜ë©´ ê·¸ëƒ¥ jmp $+5ë§Œ NOP í•œ ì±„ë¡œ ë‘”ë‹¤
                                pass
    return patches

                            
def deflat(addr, main_asmcfg):
    # 1) dispatcher ì²´ì¸ ë¶„ì„
    relevant_blocks, dispatcher, pre_dispatcher = get_cff_info(main_asmcfg, dispatcher=addr)
    state_to_target = build_dispatcher_map(main_asmcfg, dispatcher)
    _warned_keep = set()          # {(block_off, tuple(sorted(cands)))}  í˜•íƒœ
    _uncertain_summary = {}
    def _warn_keep_once(block_off, cand_set):
        """ê°™ì€ ë¸”ë¡/ê°™ì€ í›„ë³´ ì§‘í•©ì— ëŒ€í•´ ê²½ê³ ëŠ” 1ë²ˆë§Œ ì°ê³ ,
        ë§ˆì§€ë§‰ì— ìš”ì•½ì„ ìœ„í•´ ìˆ˜ì§‘í•œë‹¤."""
        key = (block_off, None if cand_set is None else tuple(sorted(cand_set)))
        if key in _warned_keep:
            return
        _warned_keep.add(key)

        if cand_set:
            msg = ", ".join(sorted(hex(x) for x in cand_set))
        else:
            msg = "None"
        print(f"[WARN] keeping tail JMP at {hex(block_off)}; candidates={msg}")

        if cand_set:
            _uncertain_summary.setdefault(block_off, set()).update(cand_set)

    patches = []
    # â˜… ëª¨ë“  ì²´ì¸ ê³µí†µ ìƒíƒœ (ì¤‘ë³µ/ì¶©ëŒ/ì¤‘ë³µ NOP ë°©ì§€)
    jmp_target_by_off = {}   # off -> target (ì´ë¯¸ ê°™ì€ íƒ€ê¹ƒìœ¼ë¡œ íŒ¨ì¹˜í–ˆëŠ”ì§€ ê¸°ë¡)
    jmp_conflicts     = set()# ì„œë¡œ ë‹¤ë¥¸ íƒ€ê¹ƒìœ¼ë¡œ ì‹œë„ëœ offë“¤(â†’ íŒ¨ì¹˜ ê¸ˆì§€)
    nop_sites         = set()# ì´ë¯¸ NOP ì°ì€ ì˜¤í”„ì…‹ë“¤(ì¤‘ë³µ ë°©ì§€)

    # 2) ê° stateì˜ target_blockë¶€í„° ì²´ì¸ ë”°ë¼ ì§ì ‘ ì—°ê²°
    for state_val, target_bb in state_to_target.items():
        visited_chain = set()
        cur = target_bb

        # ì²´ì¸ë³„ ì»¨í…ìŠ¤íŠ¸ (ìƒìˆ˜ ì „íŒŒ)
        known_mem  = {}   # ('RBP', -0x10) -> int
        known_regs = {}

        while True:
            if cur in visited_chain:
                break
            visited_chain.add(cur)

            block  = main_asmcfg.getby_offset(cur)
            instrs = block.lines

            tail_off = _find_tail_jmp_to_dispatcher(block, dispatcher, main_asmcfg)
            next_state_set = extract_next_state(block, known_mem=known_mem, known_regs=known_regs)

            if next_state_set is None or len(next_state_set) >= 2:
                # ğŸ”» ì—¬ê¸°ì„œë§Œ í”¼í”„í™€ ìˆ˜í–‰
                ph = peephole_fold_jcc_skip_jmp(block, dispatcher_addr=dispatcher)
                if ph:
                    patches.extend(ph)
                print(f"[WARN] keeping tail JMP at {hex(cur)}; candidates="
                    f"{'None' if next_state_set is None else ', '.join(sorted(hex(x) for x in next_state_set))}")

                _capture_regs_for_next(block, known_regs, known_mem)
                _capture_stack_consts_for_next(block, known_mem, known_regs)
                break
            
            
            forbid = {tail_off} if tail_off is not None else set()
            ph_patches = peephole_fold_jcc_skip_jmp(block, dispatcher, forbid_offsets=forbid)
            patches.extend(ph_patches)

            # í”¼í”„í™€ë¡œ tail jmp(near)ê°€ ì´ë¯¸ ì œê±°ë˜ì—ˆëŠ”ì§€ ì²´í¬ â†’ ê·¸ëŸ¼ direct jmpëŠ” ì“°ì§€ ì•ŠìŒ
            peephole_killed_tail = any(
                isinstance(p, PatchNop) and p.offset == tail_off for p in ph_patches
            )

            # next_state ê³„ì‚° (ì»¨í…ìŠ¤íŠ¸ ì „ë‹¬)
            next_state_set = extract_next_state(block, known_mem=known_mem, known_regs=known_regs)

            # ë¶ˆí™•ì •(ì—†ìŒ/ë³µìˆ˜) â†’ ì•ˆì „í•˜ê²Œ ë””ìŠ¤íŒ¨ì²˜ ìœ ì§€
            if not next_state_set or len(next_state_set) >= 2:
                _warn_keep_once(cur, None if not next_state_set else set(next_state_set))
                _capture_regs_for_next(block, known_regs, known_mem)
                _capture_stack_consts_for_next(block, known_mem, known_regs)
                break

            # ë‹¨ì¼ í›„ë³´
            next_state = next(iter(next_state_set))
            nxt = state_to_target.get(next_state)
            if nxt is None:
                # ì²´ì¸ ì¢…ê²°
                _capture_regs_for_next(block, known_regs, known_mem)
                _capture_stack_consts_for_next(block, known_mem, known_regs)
                break

            # ==== tail JMP êµì²´ (â˜… í•œ ë²ˆë§Œ, ì¶©ëŒ/ì¤‘ë³µ ë°©ì§€) ====
            if tail_off is not None and not peephole_killed_tail:
                last = instrs[-1]
                off  = last.offset

                prev = jmp_target_by_off.get(off)
                if prev is not None and prev != nxt:
                    # ì„œë¡œ ë‹¤ë¥¸ íƒ€ê¹ƒìœ¼ë¡œ ë‘ ë²ˆ ì‹œë„ â†’ ì´ ì˜¤í”„ì…‹ì€ ë””ìŠ¤íŒ¨ì²˜ ìœ ì§€
                    if off not in jmp_conflicts:
                        jmp_conflicts.add(off)
                        print(f"[CONFLICT] jmp@{hex(off)} targets {hex(prev)} vs {hex(nxt)} â†’ keep dispatcher")
                elif prev == nxt:
                    # ê°™ì€ íƒ€ê¹ƒìœ¼ë¡œëŠ” ì´ë¯¸ íŒ¨ì¹˜í•¨ â†’ ì¬ì‹œë„/ë¡œê·¸ ëª¨ë‘ ìŠ¤í‚µ
                    pass
                else:
                    # ìµœì´ˆ íŒ¨ì¹˜
                    jmp_target_by_off[off] = nxt
                    jbytes = make_rel32_jmp_bytes(off, nxt, last.l)
                    patches.append(PatchBytes(off, jbytes))
                    print(f"[INFO] Direct JMP patch {hex(off)} â†’ {hex(nxt)} (len={last.l})")

                    # â˜… state write NOP: switchVarì— ì“°ëŠ” movë§Œ, ê·¸ë¦¬ê³  ì´ ë¸”ë¡ì´ ì‹¤ì œë¡œ direct JMP ëì„ ë•Œ 1íšŒë§Œ
                    for ins in instrs:
                        if ins.name.lower() == 'mov' and len(ins.args) == 2:
                            dst, src = ins.args
                            if _is_switchvar_mem(dst) and ins.offset not in nop_sites:
                                patches.append(PatchNop(ins.offset, ins.l))
                                nop_sites.add(ins.offset)
            else:
                print(f"[WARN] No tail JMP...")

            # ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (REG â†’ MEM)
            _capture_regs_for_next(block, known_regs, known_mem)
            _capture_stack_consts_for_next(block, known_mem, known_regs)

            # ë‹¤ìŒ ë¸”ë¡ ì§„í–‰
            if nxt in visited_chain:
                break
            cur = nxt

    # ==== ì²´ì¸ ëª¨ë‘ ëë‚œ ë’¤: ì¶©ëŒ/ì¤‘ë³µ ì •ë¦¬ ====
    if jmp_conflicts:
        # ì¶©ëŒë‚œ ì˜¤í”„ì…‹ì˜ PatchBytesëŠ” ëª¨ë‘ ì œê±°(ë””ìŠ¤íŒ¨ì²˜ ìœ ì§€)
        patches = [p for p in patches
                   if not (isinstance(p, PatchBytes) and p.offset in jmp_conflicts)]

    # ìµœì¢… dedup (ë™ì¼ ì˜¤í”„ì…‹/ë°ì´í„° ì¤‘ë³µ ì œê±°)
    seen = set()
    dedup = []
    for p in patches:
        key = (p.__class__.__name__, p.offset, getattr(p, 'data', None))
        if key in seen:
            continue
        seen.add(key)
        dedup.append(p)
    patches = dedup

    print(f"[SUMMARY] dispatcher cases: {len(state_to_target)}")
    djmps = sum(1 for p in patches if isinstance(p, PatchBytes))
    nops  = sum(1 for p in patches if isinstance(p, PatchNop))
    if _uncertain_summary:
        print(f"[SUMMARY] unresolved blocks (unique): {len(_uncertain_summary)}")
        for off in sorted(_uncertain_summary):
            cands = ", ".join(sorted(hex(x) for x in _uncertain_summary[off]))
            print(f"   {hex(off)} -> {cands}")
        print(f"[SUMMARY] patches written: {djmps} direct jmps, {nops} nops")
        return patches





if __name__ == '__main__':
    parser = ArgumentParser("modeflattener")
    parser.add_argument('filename', help="file to deobfuscate")
    parser.add_argument('patch_filename', help="deobfuscated file name")
    parser.add_argument('address', help="obfuscated function address")
    parser.add_argument('-a', "--all", action="store_true",
                        help="find and deobfuscate all flattened functions recursively")
    parser.add_argument('-l', "--log", help="logging level (default=INFO)",
                        default='info')

    args = parser.parse_args()

    loglevel = args.log
    _log = setup_logger(loglevel)

    deobf_start_time = time.time()

    forg = open(args.filename, 'rb')
    fpatch = open(args.patch_filename, 'wb')
    fpatch.write(forg.read())

    loc_db = LocationDB()

    global cont
    cont = Container.from_stream(open(args.filename, 'rb'), loc_db)

    supported_arch = ['x86_32', 'x86_64']
    _log.info("Architecture : %s"  % cont.arch)

    if cont.arch not in supported_arch:
        _log.error("Architecture unsupported : %s" % cont.arch)
        exit(1)

    section_ep = cont.bin_stream.bin.virt.parent.getsectionbyvad(cont.entry_point).sh
    bin_base_addr = section_ep.addr - section_ep.offset
    _log.info('bin_base_addr: %#x' % bin_base_addr)

    machine = Machine(cont.arch)
    mdis = machine.dis_engine(cont.bin_stream, loc_db=loc_db)

    ad = int(args.address, 0)
    todo = [(mdis, None, ad)]
    done = set()
    all_funcs = set()
    all_funcs_blocks = {}

    while todo:
        mdis, caller, ad = todo.pop(0)
        if ad in done:
            continue
        done.add(ad)
        asmcfg = mdis.dis_multiblock(ad)
        lifter = machine.lifter_model_call(mdis.loc_db)
        ircfg = lifter.new_ircfg_from_asmcfg(asmcfg)

        _log.info('found func @ %#x (%d)' % (ad, len(all_funcs)))

        all_funcs.add(ad)
        all_funcs_blocks[ad] = (asmcfg, ircfg)

        if args.all:
            for block in asmcfg.blocks:
                instr = block.get_subcall_instr()
                if not instr:
                    continue
                for dest in instr.getdstflow(mdis.loc_db):
                    if not dest.is_loc():
                        continue
                    offset = mdis.loc_db.get_location_offset(dest.loc_key)
                    todo.append((mdis, instr, offset))

    for ad in all_funcs:
        asmcfg = all_funcs_blocks[ad][0]
        score = calc_flattening_score(asmcfg)

        # flattening score ë¬´ì‹œ: address ì§ì ‘ ì§€ì •í•œ ê²½ìš°ëŠ” ë¬´ì¡°ê±´ deflat ì‹œë„
        if not args.all or ad == int(args.address, 0):
            print('-------------------------')
            print('|    func : %#x    |' % ad)
            print('-------------------------')
            fcn_start_time = time.time()
            patches = deflat(ad, all_funcs_blocks[ad][0])

            if patches:
                for patch in patches:
                    offset = patch.offset
                    data = patch.data

                    print(f"[+] Writing patch at {hex(offset)}: {len(data)} bytes")

                    fpatch.seek(offset - bin_base_addr)
                    fpatch.write(data)

                fcn_end_time = time.time() - fcn_start_time
                _log.info("PATCHING SUCCESSFUL for function @ %#x (%.2f secs)\n" % (ad, fcn_end_time))
            else:
                _log.error("PATCHING UNSUCCESSFUL for function @ %#x\n" % ad)

        else:
            _log.error("unable to deobfuscate func %#x (cff score = %f)\n" % (ad, score))

    fpatch.close()
    deobf_end_time = time.time() - deobf_start_time

    _log.info("Deobfuscated file saved at '%s' (Total Time Taken : %.2f secs)" % (args.patch_filename, deobf_end_time))